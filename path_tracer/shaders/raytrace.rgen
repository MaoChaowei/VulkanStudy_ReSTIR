#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension  GL_ARB_shader_clock:require

#include "raycommon.glsl"
#include "host_device.h"
#include "sampling.glsl"


// clang-format off
layout(location = 0) rayPayloadEXT hitPayload rpd;

layout(set = 0, binding = eTlas) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = eOutImage, rgba32f) uniform image2D image;
layout(set = 1, binding = eGlobals) uniform _GlobalUniforms { GlobalUniforms uni; };
layout(push_constant) uniform _PushConstantRay { PushConstantRay pcRay; };
// clang-format on

# define MAX_SPP pcRay.spp_num
# define MAX_DEPTH pcRay.max_depth
# define ALGORITHM pcRay.algo_type

void main()
{
  // Initialize the random number
  uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));

  const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
  const vec2 inUV        = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
  vec2       d           = inUV * 2.0 - 1.0;

  vec4 origin    = uni.viewInverse * vec4(0, 0, 0, 1);
  vec4 target    = uni.projInverse * vec4(d.x, d.y, 1, 1);
  vec4 direction = uni.viewInverse * vec4(normalize(target.xyz), 0);

  uint  rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin     = 0.001;
  float tMax     = 10000.0;
  rpd.seed              = seed;

  vec3 curRadiance  = vec3(0);
  for(int spp=0;spp<MAX_SPP;++spp)
  {
    vec3 curThroughPut = vec3(1);
    rpd.emit_radiance     = vec3(0);
    rpd.direct_radiance   = vec3(0);
    rpd.depth             = 0;
    rpd.ray.origin        = origin.xyz;
    rpd.ray.direction     = direction.xyz;
    rpd.indirect_weight   = vec3(0);

    for(; rpd.depth < MAX_DEPTH; rpd.depth++)
    {
      traceRayEXT(topLevelAS,        // acceleration structure
                  rayFlags,          // rayFlags
                  0xFF,              // cullMask
                  0,                 // sbtRecordOffset
                  0,                 // sbtRecordStride
                  0,                 // missIndex
                  rpd.ray.origin,     // ray origin
                  tMin,              // ray min range
                  rpd.ray.direction,  // ray direction
                  tMax,              // ray max range
                  0                  // payload (location = 0)
      );
      if(rpd.depth==0){
        curRadiance+=curThroughPut*rpd.emit_radiance;
      }
      curRadiance += curThroughPut*(rpd.direct_radiance);
      curThroughPut *= rpd.indirect_weight;

      // RR
      float RR=max(min((curThroughPut[0]+curThroughPut[1]+curThroughPut[2])*0.3333333f,0.95f),0.2f);
      if(rnd(rpd.seed)<RR){
          curThroughPut/=RR;
      }
      else{
        break;
      }
    }
  }

  curRadiance/=MAX_SPP;

  if(pcRay.frame_num>0 && ALGORITHM==NEE_temporal_reuse)
  {
    float a=1.0f/float(pcRay.frame_num+1);
    vec3 old_color=imageLoad(image,ivec2(gl_LaunchIDEXT.xy)).xyz;
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color,curRadiance,a), 1.f));
  }
  else
  {
    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(curRadiance, 1.f));
  }
  
}
